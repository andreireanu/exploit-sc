#![no_std]

use lottery::ProxyTrait as _;

const MAX_NR: u64 = 3000;
const ONE_HUNDREDTH_EGLD: u64 = 10000000000000000;

mod callee_proxy {
    multiversx_sc::imports!();

    #[multiversx_sc::proxy]
    pub trait CalleeContract {
        #[payable("*")]
        #[endpoint(endpointName)]
        fn endpoint_name(&self);
    }
}

multiversx_sc::imports!();

#[multiversx_sc::contract]
pub trait ExploitContract {
    #[init]
    fn init(&self, fake: ManagedAddress, real: ManagedAddress) {
        self.fake_lottery_address().set(fake);
        self.real_lottery_address().set(real);
    }

    #[proxy]
    fn contract_proxy(&self, sc_address: ManagedAddress) -> lottery::Proxy<Self::Api>;

    #[proxy]
    fn real_contract_proxy(&self, sc_address: ManagedAddress) -> callee_proxy::Proxy<Self::Api>;

    #[view(fakeLotteryAddress)]
    #[storage_mapper("fake_lottery_address")]
    fn fake_lottery_address(&self) -> SingleValueMapper<ManagedAddress>;

    #[view(realLotteryAddress)]
    #[storage_mapper("real_lottery_address")]
    fn real_lottery_address(&self) -> SingleValueMapper<ManagedAddress>;

    #[endpoint(proxyCall)]
    fn caller_endpoint(&self, amount: BigUint) {
        let fake_address = self.fake_lottery_address().get();
        let real_address = self.real_lottery_address().get();

        let mut rand_source = RandomnessSource::new();
        let rand_nr = rand_source.next_u64_in_range(1, MAX_NR);
        if rand_nr < 1000 {
            let caller = self.blockchain().get_caller();
            self.send()
                .direct_egld(&caller, &BigUint::from(2 * ONE_HUNDREDTH_EGLD));
        }

    }
}
